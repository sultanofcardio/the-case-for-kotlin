# The case for Kotlin

## New shiny
This one is obvious: Kotlin is much younger than Java and was designed from the 
ground up with modern features in mind. While newer versions of Java may have 
some of these features, the language is carrying around decades of backwards 
compatibility that makes utilizing certain concepts awkward.

## Java interoperability
The Kotlin compiler (kotlinc) produces JVM bytecode compatible with Java 6, 7, and 8 
depending on the flag specified. Switching versions requires no change to 
source code, allowing developers to use modern language features while producing 
bytecode compatible with JRE 1.6.

What's more is that kotlinc supports mixed codebases of Java and Kotlin, allowing for 
gradual migration from Java to Kotlin. One could also maintain a long-term 
mixed codebase if desired.

Finally, Kotlin supports all the build systems, libraries, frameworks, and tooling
that Java does.

## More features than Java

### More compilation targets
### First class functions
### Inline functions
### Generic type variance
### Built-in singleton support
### Properties not fields
### Extension functions
### Extension properties
### Coroutines are better than threads
### Nullable types
### Value types
### Property delegates
### Named arguments
### Object destructuring


## Kotlin is more pleasant to write
### Conciseness
#### `public static void main`

## Classes of errors avoided in Kotlin

## Companies using Kotlin

## Googleâ€™s first-class support
